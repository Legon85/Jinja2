from jinja2 import Environment, FileSystemLoader

# НАСЛЕДОВАНИЕ шаблонов позволяем уменьшать объём дублируемого кода в шаблонах.

# Для простоты восприятия создадим новый файл с шаблоном ex_main.htm в подкаталоге templates в котором используется
# новый тип блоков - именованный блоки:{% block title %}{% endblock %}, {% block content %} {% endblock %}.
# <!DOCTYPE html>
# <html>
# <head>
#     <meta charset="utf-8">
#     <title>{% block title %}{% endblock %}</title>
# </head>
# <body>
#
# {% block content %}
# {% endblock %}
#
# </body>
# </html>

# Само расширение шаблона реализуется с помощью другого шаблона about.htm. Он находится так же в подкаталоге
# templates и его содержимое следующее:

# {% extends 'ex_main.htm' %}
#
# {% block title %}О сайте{% endblock %}
#
# {% block content %}
# <h1>О сайте</h1>
# <p>Классный сайт, если его доделать.</p>
# {% endblock %}

# Первой строчкой идёт extends и далее имя того шаблона, который мы собираемся расширять - ex_main.htm т.е. по сути
# имя базового шаблона, на основе которого строится страница about.htm Далее мы говорим, что в именованно блоке {%
# block title %}О сайте{% endblock %}  должна помещаться информация: О сайте. А в именованном блоке
# {% block content %} Должна помещаться информация с заголовком: О сайте и абзац с содержимым:
# Классный сайт, если его доделать.
# Ну и тем самым в базовом шаблоне ex_main.htm вместо именованного блока {% block title %} будет подставлено: О
# сайте, а вместо  {% block content %} - О сайте и Классный сайт, если его доделать. Весь остальной скелет нашей
# страницы будет взят из файла ex_main.htm.

# В программе на python вывести исходное содержимое можно следующим образом:
file_loader = FileSystemLoader('templates')
env = Environment(loader=file_loader)
template = env.get_template('about.htm')
output = template.render()

print(output)
print("-" * 60)
# ->
# <!DOCTYPE html>
# <html>
# <head>
#     <meta charset="utf-8">
#     <title>О сайте</title>
# </head>
# <body>
#
#
# <h1>О сайте</h1>
# <p>Классный сайт, если его доделать.</p>
#
#
# </body>
# </html>

# Но часто на практике бывает так, что базовые шаблоны типа ex_main.htm могут находиться в каком-то другом
# подкаталоге. Например, рассмотрим ситуацию когда базовый шаблон  default.tpl находится в подкаталоге layout
# относительно текущего подшаблона about.htm
# Если мы about.htm расширяем на основе шаблона default.tpl который находится в подкаталоге layout, то значит этот
# подкаталог layout и должен находиться относительно этого шаблона about.htm
# Содержимое файла default.tpl для примера такое же как и у файла ex_main.htm
# Что бы сделать расширение используя файл default.tpl необходимо в файле about.htm прописать extends в следующем виде:
# {% extends 'ex_main.htm' %} и тогда всё будет работать в том же виде.
print(output)
print("-" * 60)

# Если, как у нас в примере, в именованных блоках {% block title %} и {% block content %} есть одинаковая информация -
# - 'О сайте' то, что бы не дублировать эту информацию, можно, например в блоке {% block content %}, воспользоваться
# конструкцией {{ self.title() }}. Это позволяет подставить то, что находится в именованном блоке title подставить в
# блок content. Подставим, распечатаем и увидим тот же результат.

# Ну а раз есть такой параметр как self значит должен быть и параметр super для обращения к блоку уже базового
# шаблона и взятия оттуда информации.

# Для этого нужно в шаблоне about.htm, например в блоке {% block content %} прописать {{ super() }}:
# {% extends 'layout/default.tpl' %}
#
# {% block title %}О сайте{% endblock %}
#
# {% block content %}
# {{ super() }}
# <h1>{{ self.title() }}</h1>
# <p>Классный сайт, если его доделать.</p>
# {% endblock %}

# А в базовом шаблоне default.tpl соответственно в блоке {% block content %} пропишем 'Блок контента':

# <!DOCTYPE html>
# <html>
# <head>
#     <meta charset="utf-8">
#     <title>{% block title %}{% endblock %}</title>
# </head>
# <body>
#
# {% block content %}
# Блок контента
# {% endblock %}
#
# </body>
# </html>

print(output)
print("-" * 60)

# ->  Видим теперь текст Блок контента, который был взять из базового шаблона default.tpl:

# <!DOCTYPE html>
# <html>
# <head>
#     <meta charset="utf-8">
#     <title>О сайте</title>
# </head>
# <body>
#
#
#
# Блок контента
#
# <h1>О сайте</h1>
# <p>Классный сайт, если его доделать.</p>
#
#
# </body>
# </html>

# При этом надо понимать, что всё что написано в дочернем шаблоне about.htm будет подставляться всегда в базовый
# default.tpl не зависимо от того что на текущий момент находится в базовом шаблоне в именованных блоках.
# А уж если мы что-то хотим сохранить из базового шаблона, то как было показано выше нужно использовать функцию супер
# в дочернем шаблоне для загрузки этих данных из базового.

# В базовых шаблонах так же можно делать вложенные блоки, вызываемы так же через super() соответственно.

# Пропишем в базовом шаблоне default.tpl в block content вложенный блок:
# <!DOCTYPE html>
# <html>
# <head>
#     <meta charset="utf-8">
#     <title>{% block title %}{% endblock %}</title>
# </head>
# <body>
#
# {% block content %}
#         {% block table_contents %}
#         <ul>
#         {% for li in list_table -%}
#         <li>{{li}}</li>
#         {% endfor -%}
#         </ul>
#         {% endblock table_contents %}
#
# {% endblock content %}
#
# </body>
# </html>

# В дочернем шаблоне about.htm этот блок соответственно будет загружаться благодаря super().

# Ну и чтобы наполнить вложенный блок содержимым определим в программе список subs и передадим его далее в метод render.

subs = ['Математика', 'Физика', 'Информатика', 'Русский']

file_loader = FileSystemLoader('templates')
env = Environment(loader=file_loader)
template = env.get_template('about.htm')
output = template.render(list_table=subs)

print(output)
print("-" * 60)

# ->
# <!DOCTYPE html>
# <html>
# <head>
#     <meta charset="utf-8">
#     <title>О сайте</title>
# </head>
# <body>
#
#
#
#         <ul>
#         <li>Математика</li>
#         <li>Физика</li>
#         <li>Информатика</li>
#         <li>Русский</li>
#         </ul>
#
#
#
# <h1>О сайте</h1>
# <p>Классный сайт, если его доделать.</p>
#
# </body>
# </html>


# По идее в данном случае правильнее даже прописывать super в дочернем шаблоне в таком виде:
# {% block table_contents %}{{ super() }}{% endblock %} поскольку так мы сможем гибко управлять добавлением и
# удалением нужно нам информации всего лишь удалив не нужный нам вложенный блок например.

# Предположим нужно во вложенном блоке приведённом выше добавить тег <p>, в котором уже будут находиться наши названия
# предметов из списка. Для этого можно прописать новый блок в дочернем классе:
# {% block item %}<p class="item">{{ super() }}</p>{% endblock %}  внутри которого и определить тег <p> нужными
# параметрами(class="item" например). А так же внутри его прописать super() для получения данных из вложенного блока
# нашего базового шаблона.

# Но при этом в дочернем шаблоне нужно уже элементы списка, по которым проходится блок {% for li in list_table -%},
# а именно <li>, находящиеся теперь в блоке {% block item %}, прописывать через слово scoped. Потому, что всё что
# находится в данном случае в блоке {% block item %} вне контекста блока {% for li in list_table -%}. То есть без слова
# scoped <li> в блоке {% block item %} была бы не определена. Для этого и нужен scoped!